<div class="metric-title">Resumo de Pedidos</div>
                    <div><span class="label">Total:</span> <span id="totalOrders" class="metric-value">0</span></div>
                    <div><span class="label">Em Andamento:</span> <span id="ongoingOrders" class="metric-value">0</span></div>
                    <div><span class="label">Tempo Médio de Preparo:</span> <span id="avgPrepTime" class="metric-value">0 min</span></div>
                    <div><span class="label">Pedidos em loja:</span> <span id="readyOrders" class="metric-value">0</span> <button class="view-button" onclick="showReadyOrders()">Ver</button></div>
                    <div><span class="label">Cancelados:</span> <span id="cancelledOrders" class="metric-value">0</span></div>
                    <div><span class="label">Prioridades:</span> <span id="priorityOrders" class="metric-value">0</span> <button class="view-button" onclick="showPriorityOrders()">Ver</button> <button class="print-button" onclick="printPriorityOrders()">Imprimir</button></div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Valor Total</div>
                    <div><span class="label">Hoje:</span> <span id="totalValue" class="metric-value">R$ 0,00</span></div>
                    <div><span class="label">Ontem:</span> <span id="yesterdayValue" class="metric-value">R$ 0,00</span></div>
                    <div><span class="label">Ticket Médio:</span> <span id="averageTicket" class="metric-value">R$ 0,00</span></div>
                    <div id="paymentBreakdown"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Entregas por Motoboy (Hoje)</div>
                    <div id="courierDeliveries"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="ongoingModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="ongoingContent"></div>
        </div>
    </div>
    <div id="readyOrdersModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="readyOrdersContent"></div>
        </div>
    </div>
    <div id="priorityOrdersModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="priorityOrdersContent"></div>
        </div>
    </div>
    <div id="cancellationPopup" class="cancellation-popup">
        <span class="close" onclick="closeCancellationPopup()">&times;</span>
        <p id="cancellationMessage"></p>
        <button class="hide-notification-button" onclick="hideCancellationNotification()">Ocultar notificação</button>
    </div>
    <div id="sameAddressPopup" class="same-address-popup">
        <span class="close" onclick="closeSameAddressPopup()">&times;</span>
        <p id="sameAddressMessage"></p>
        <button class="hide-notification-button" onclick="hideSameAddressNotification()">Ocultar notificação</button>
    </div>
    <script>
        // Configuração do Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyB-pF2lRStLTN9Xw9aYQj962qdNFyUXI2E",
            authDomain: "cabana-8d55e.firebaseapp.com",
            databaseURL: "https://cabana-8d55e-default-rtdb.firebaseio.com",
            projectId: "cabana-8d55e",
            storageBucket: "cabana-8d55e.appspot.com",
            messagingSenderId: "706144237954",
            appId: "1:706144237954:web:345c10370972486afc779b",
            measurementId: "G-96Y337GYT8"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    let map;
    let heatmap;
    let markers = {};
    const firebaseFunctionUrl = 'https://us-central1-cabana-8d55e.cloudfunctions.net/getFoodyOrders/proxy';
    const trackingUrl = 'https://us-central1-cabana-8d55e.cloudfunctions.net/getFoodyTracking/tracking';
    const authToken = '8d7c77946d534444a168bb7da794febf';
    const foodyApiUrl = 'https://app.foodydelivery.com/rest/1.2/orders/';

    let orderPrepTimes = {};
    let totalPrepTime = 0;
    let preparedOrders = 0;
    let totalOrdersCount = 0;
    let totalOrdersValue = 0;
    let yesterdayOrdersValue = 0;
    let paymentMethods = {
        money: 0,
        card: 0,
        online: 0
    };
    let currentOrders = [];
    let allOrdersToday = [];
    let courierDeliveries = {};
    let cancelledOrders = 0;
    let lastOrderStatuses = {};
    let priorityOrders = [];
    let sameAddressOrders = {};
    let shownSameAddressNotifications = new Set();
    let lastShownNotificationTime = 0;
    let hiddenNotifications = {
        cancellation: false,
        sameAddress: false
    };

    function saveDataToLocalStorage() {
        localStorage.setItem('orderPrepTimes', JSON.stringify(orderPrepTimes));
        localStorage.setItem('totalPrepTime', totalPrepTime.toString());
        localStorage.setItem('preparedOrders', preparedOrders.toString());
        localStorage.setItem('totalOrdersCount', totalOrdersCount.toString());
        localStorage.setItem('totalOrdersValue', totalOrdersValue.toString());
        localStorage.setItem('yesterdayOrdersValue', yesterdayOrdersValue.toString());
        localStorage.setItem('paymentMethods', JSON.stringify(paymentMethods));
        localStorage.setItem('courierDeliveries', JSON.stringify(courierDeliveries));
        localStorage.setItem('cancelledOrders', cancelledOrders.toString());
        localStorage.setItem('priorityOrders', JSON.stringify(priorityOrders));
        localStorage.setItem('sameAddressOrders', JSON.stringify(sameAddressOrders));
        localStorage.setItem('shownSameAddressNotifications', JSON.stringify(Array.from(shownSameAddressNotifications)));
        localStorage.setItem('lastShownNotificationTime', lastShownNotificationTime.toString());
        localStorage.setItem('hiddenNotifications', JSON.stringify(hiddenNotifications));
    }

    function loadDataFromLocalStorage() {
        const storedOrderPrepTimes = localStorage.getItem('orderPrepTimes');
        if (storedOrderPrepTimes) orderPrepTimes = JSON.parse(storedOrderPrepTimes);
        const storedTotalPrepTime = localStorage.getItem('totalPrepTime');
        if (storedTotalPrepTime) totalPrepTime = parseFloat(storedTotalPrepTime);
        const storedPreparedOrders = localStorage.getItem('preparedOrders');
        if (storedPreparedOrders) preparedOrders = parseInt(storedPreparedOrders);
        const storedTotalOrdersCount = localStorage.getItem('totalOrdersCount');
        if (storedTotalOrdersCount) totalOrdersCount = parseInt(storedTotalOrdersCount);
        const storedTotalOrdersValue = localStorage.getItem('totalOrdersValue');
        if (storedTotalOrdersValue) totalOrdersValue = parseFloat(storedTotalOrdersValue);
        const storedYesterdayOrdersValue = localStorage.getItem('yesterdayOrdersValue');
        if (storedYesterdayOrdersValue) yesterdayOrdersValue = parseFloat(storedYesterdayOrdersValue);
        const storedPaymentMethods = localStorage.getItem('paymentMethods');
        if (storedPaymentMethods) paymentMethods = JSON.parse(storedPaymentMethods);
        const storedCourierDeliveries = localStorage.getItem('courierDeliveries');
        if (storedCourierDeliveries) courierDeliveries = JSON.parse(storedCourierDeliveries);
        const storedCancelledOrders = localStorage.getItem('cancelledOrders');
        if (storedCancelledOrders) cancelledOrders = parseInt(storedCancelledOrders);
        const storedPriorityOrders = localStorage.getItem('priorityOrders');
        if (storedPriorityOrders) priorityOrders = JSON.parse(storedPriorityOrders);
        const storedSameAddressOrders = localStorage.getItem('sameAddressOrders');
        if (storedSameAddressOrders) sameAddressOrders = JSON.parse(storedSameAddressOrders);
        const storedShownSameAddressNotifications = localStorage.getItem('shownSameAddressNotifications');
        if (storedShownSameAddressNotifications) shownSameAddressNotifications = new Set(JSON.parse(storedShownSameAddressNotifications));
        const storedLastShownNotificationTime = localStorage.getItem('lastShownNotificationTime');
        if (storedLastShownNotificationTime) lastShownNotificationTime = parseInt(storedLastShownNotificationTime);
        const storedHiddenNotifications = localStorage.getItem('hiddenNotifications');
        if (storedHiddenNotifications) hiddenNotifications = JSON.parse(storedHiddenNotifications);
    }

    function initMap() {
        const centerAddress = { lat: -5.750636, lng: -35.254625 };
        map = new google.maps.Map(document.getElementById('map'), {
            center: centerAddress,
            zoom: 12
        });
        heatmap = new google.maps.visualization.HeatmapLayer({
            data: [],
            map: map
        });
        new google.maps.Marker({
            position: centerAddress,
            map: map,
            title: "Rua Serra do Mar, 1216, Potengi",
            icon: {
                url: "https://maps.google.com/mapfiles/ms/icons/blue-dot.png",
                scaledSize: new google.maps.Size(40, 40)
            }
        });
    }

    function formatDate(date) {
        return date.toISOString().replace(/\.\d{3}Z$/, '-03:00');
    }

    function isWithinTimeRange(date) {
        const hour = date.getHours();
        const minutes = date.getMinutes();
        const totalMinutes = hour * 60 + minutes;
        return totalMinutes >= 12 * 60 + 30 && totalMinutes <= 22 * 60 + 30;
    }

    async function fetchOrders() {
        try {
            const now = new Date();
            const startDate = formatDate(new Date(now.setHours(0, 0, 0, 0)));
            const endDate = formatDate(new Date());
            const response = await axios.get(firebaseFunctionUrl, {
                headers: {
                    'Authorization': authToken,
                    'Content-Type': 'application/json;charset=UTF-8'
                },
                params: {
                    url: `${foodyApiUrl}?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`
                }
            });
            console.log('Pedidos recebidos:', response.data);
            allOrdersToday = response.data.filter(order => {
                const orderDate = new Date(order.creationDate);
                return isWithinTimeRange(orderDate);
            });
            const filteredOrders = allOrdersToday.filter(order =>
                ['open', 'accepted', 'ready', 'onGoing', 'dispatched'].includes(order.status)
            );
            currentOrders = filteredOrders;
            priorityOrders = currentOrders.filter(order => order.status === 'accepted');
            updateOrderList(currentOrders);
            updateMap(currentOrders);
            updateDashboard(allOrdersToday);
            updatePrepTimes(currentOrders);
            updateCourierDeliveries(allOrdersToday);
            checkForCancelledOrders(allOrdersToday);
            checkForSameAddressOrders(allOrdersToday);
            fetchYesterdayOrders();
            saveDataToLocalStorage();
        } catch (error) {
            console.error('Erro ao buscar pedidos:', error);
            document.getElementById('orderList').innerHTML = '<p class="error">Erro ao carregar pedidos. Por favor, tente novamente mais tarde.</p>';
        }
    }

    async function fetchYesterdayOrders() {
        try {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const startDate = formatDate(new Date(yesterday.setHours(0, 0, 0, 0)));
            const endDate = formatDate(new Date(yesterday.setHours(23, 59, 59, 999)));
            const response = await axios.get(firebaseFunctionUrl, {
                headers: {
                    'Authorization': authToken,
                    'Content-Type': 'application/json;charset=UTF-8'
                },
                params: {
                    url: `${foodyApiUrl}?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`
                }
            });
            const yesterdayOrders = response.data.filter(order => isWithinTimeRange(new Date(order.creationDate)));
            yesterdayOrdersValue = yesterdayOrders.reduce((total, order) => total + (order.orderTotal || 0), 0);
            document.getElementById('yesterdayValue').textContent = `R$ ${yesterdayOrdersValue.toFixed(2)}`;
            saveDataToLocalStorage();
        } catch (error) {
            console.error('Erro ao buscar pedidos de ontem:', error);
        }
    }

    function updateOrderList(orders) {
        const orderList = document.getElementById('orderList');
        orderList.innerHTML = '';
        orders.forEach(order => {
            const orderDiv = document.createElement('div');
            orderDiv.className = 'order-item';
            orderDiv.innerHTML = `
                <h3>Pedido #${order.id}</h3>
                <p class="status-${order.status.toLowerCase()}">${getStatusDisplay(order.status)}</p>
                <p>Cliente: ${order.customer.customerName}</p>
                ${order.courier ? `<p>Motoboy: <span class="courier-name">${order.courier.courierName}</span></p>` : ''}
                <p>Método de Pagamento: ${translatePaymentMethod(order.paymentMethod)}</p>
                <p>Total do Pedido: R$ ${order.orderTotal ? order.orderTotal.toFixed(2) : 'N/A'}</p>
                ${order.notes ? `<p>Observações: ${order.notes}</p>` : ''}
                Claro, vou continuar a partir da função updateOrderList:
function updateOrderList(orders) {
const orderList = document.getElementById('orderList');
orderList.innerHTML = '';
orders.forEach(order => {
const orderDiv = document.createElement('div');
orderDiv.className = 'order-item';
orderDiv.innerHTML =             <h3>Pedido #${order.id}</h3>             <p class="status-${order.status.toLowerCase()}">${getStatusDisplay(order.status)}</p>             <p>Cliente: ${order.customer.customerName}</p>             ${order.courier ?<p>Motoboy: <span class="courier-name">${order.courier.courierName}</span></p>: ''}             <p>Método de Pagamento: ${translatePaymentMethod(order.paymentMethod)}</p>             <p>Total do Pedido: R$ ${order.orderTotal ? order.orderTotal.toFixed(2) : 'N/A'}</p>             ${order.notes ?<p>Observações: ${order.notes}</p>: ''}             <p>Tempo de Preparo: <span id="prepTime-${order.id}">0 min</span></p>             <div class="order-options">                 <i class="fas fa-map-marker-alt" onclick="centerOrderOnMap('${order.uid}')"></i>             </div>        ;
orderList.appendChild(orderDiv);
});
}
function updateMap(orders) {
const heatmapData = [];
orders.forEach(order => {
if (order.deliveryPoint && order.deliveryPoint.coordinates) {
const { lat, lng } = order.deliveryPoint.coordinates;
let marker = markers[order-${order.uid}];
if (!marker) {
marker = new google.maps.Marker({
position: { lat, lng },
map: map,
title: Pedido #${order.id},
icon: getOrderMarkerIcon(order.status, order.id)
});
markers[order-${order.uid}] = marker;
marker.addListener('click', () => {
showOrderDetails(order);
});
} else {
marker.setPosition({ lat, lng });
marker.setIcon(getOrderMarkerIcon(order.status, order.id));
}
heatmapData.push(new google.maps.LatLng(lat, lng));
}
if (order.status === 'onGoing' || order.status === 'dispatched') {
updateCourierLocation(order);
}
});
// Remove markers for orders that no longer exist
Object.keys(markers).forEach(key => {
if (key.startsWith('order-') && !orders.some(order => order-${order.uid} === key)) {
markers[key].setMap(null);
delete markers[key];
}
});
heatmap.setData(heatmapData);
}
function getOrderMarkerIcon(status, orderId) {
let color;
switch (status) {
case 'open':
color = '#e74c3c';
break;
case 'accepted':
color = '#f1c40f';
break;
case 'ready':
color = '#8E44AD';
break;
case 'onGoing':
color = '#87CEEB';
break;
case 'dispatched':
color = '#e67e22';
break;
default:
color = 'gray';
}
return {
url: data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
<rect width="32" height="32" fill="${color}" stroke="black" stroke-width="1" />
<text x="16" y="20" font-family="Arial" font-size="12" fill="black" text-anchor="middle">${orderId}</text>
</svg>
)},
scaledSize: new google.maps.Size(32, 32),
anchor: new google.maps.Point(16, 16)
};
}
async function updateCourierLocation(order) {
try {
const response = await axios.get(trackingUrl, {
headers: {
'Authorization': authToken,
'Content-Type': 'application/json;charset=UTF-8'
},
params: {
orderUid: order.uid
}
});
const tracking = response.data;
if (tracking.courierLocationCoordinates) {
const { lat, lng } = tracking.courierLocationCoordinates;
let courierMarker = markers[courier-${order.courier.courierName}];
if (!courierMarker) {
courierMarker = new google.maps.Marker({
position: { lat, lng },
map: map,
title: Motoboy - ${order.courier.courierName},
icon: getCourierIcon(order.courier.courierName, order.status)
});
markers[courier-${order.courier.courierName}] = courierMarker;
courierMarker.addListener('click', () => {
showCourierDetails(order, tracking);
});
} else {
courierMarker.setPosition({ lat, lng });
courierMarker.setIcon(getCourierIcon(order.courier.courierName, order.status));
}
}
} catch (error) {
console.error(Erro ao buscar localização do motoboy para o pedido ${order.uid}:, error);
}
}
function getCourierIcon(courierName, status) {
return {
url: data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60">
<rect width="60" height="20" rx="10" ry="10" fill="${status === 'onGoing' ? 'red' : 'green'}" />
<text x="30" y="14" font-family="Arial" font-size="12" fill="white" text-anchor="middle">${courierName.substring(0, 5).toUpperCase()}</text>
<path d="M30 25 L20 55 L40 55 Z" fill="black" />
<circle cx="30" cy="35" r="7" fill="white" />
</svg>
)},
scaledSize: new google.maps.Size(60, 60),
anchor: new google.maps.Point(30, 30)
};
}
function centerOrderOnMap(orderUid) {
const marker = markers[order-${orderUid}] || markers[courier-${orderUid}];
if (marker) {
map.setCenter(marker.getPosition());
map.setZoom(16);
}
}
function getStatusDisplay(status) {
switch (status) {
case 'open':
return 'Aberto';
case 'accepted':
return 'Aceito';
case 'ready':
return 'Pronto';
case 'onGoing':
return 'A Caminho';
case 'dispatched':
return 'Despachado';
case 'cancelled':
return 'Cancelado';
default:
return status;
}
}
function translatePaymentMethod(method) {
switch (method) {
case 'money':
return 'Dinheiro';
case 'card':
return 'Cartão';
case 'online':
return 'Online';
default:
return method;
}
}
function showOrderDetails(order) {
const infoWindow = new google.maps.InfoWindow({
content:             <div style="max-width: 200px;">                 <h3>Pedido #${order.id}</h3>                 <p>Cliente: ${order.customer.customerName}</p>                 <p>Endereço: ${order.deliveryPoint.address}</p>                 <p>Status: ${getStatusDisplay(order.status)}</p>                 ${order.courier ?<p>Motoboy: <span class="courier-name">${order.courier.courierName}</span></p>: ''}                 <p>Método de Pagamento: ${translatePaymentMethod(order.paymentMethod)}</p>                 <p>Total do Pedido: R$ ${order.orderTotal ? order.orderTotal.toFixed(2) : 'N/A'}</p>                 ${order.notes ?<p>Observações: ${order.notes}</p>: ''}                 <p>Tempo de Preparo: ${getPrepTimeForOrder(order.id)} min</p>             </div>        
});
const marker = markers[order-${order.uid}];
if (marker) {
infoWindow.open(map, marker);
}
}
function showCourierDetails(order, tracking) {
const infoWindow = new google.maps.InfoWindow({
content:             <div style="max-width: 200px;">                 <h3>Motoboy - <span class="courier-name">${order.courier.courierName}</span></h3>                 <p>Status: ${getStatusDisplay(order.status)}</p>                 ${tracking.pointsToDelivery && tracking.pointsToDelivery.length > 0 ?                <p>Posição na rota: ${tracking.pointsToDelivery[0].position}</p>: ''}                 <p>Pedido atual: #${order.id}</p>             </div>        
});
const marker = markers[courier-${order.courier.courierName}];
if (marker) {
infoWindow.open(map, marker);
}
}
function updateDashboard(allOrders) {
totalOrdersCount = allOrders.length;
totalOrdersValue = 0;
paymentMethods = {
money: 0,
card: 0,
online: 0
};
cancelledOrders = allOrders.filter(order => order.status === 'cancelled').length;
priorityOrders = allOrders.filter(order => order.status === 'accepted');
allOrders.forEach(order => {
if (order.status !== 'cancelled') {
totalOrdersValue += order.orderTotal || 0;
const paymentType = order.paymentMethod;
paymentMethods[paymentType] = (paymentMethods[paymentType] || 0) + (order.orderTotal || 0);
}
});
document.getElementById('totalOrders').textContent = totalOrdersCount;
document.getElementById('ongoingOrders').textContent = currentOrders.filter(order => order.status === 'onGoing').length;
document.getElementById('readyOrders').textContent = currentOrders.filter(order => order.status === 'ready').length;
document.getElementById('cancelledOrders').textContent = cancelledOrders;
document.getElementById('priorityOrders').textContent = priorityOrders.length;
document.getElementById('totalValue').textContent = R$ ${totalOrdersValue.toFixed(2)};
const completedOrders = allOrders.filter(order => order.status !== 'cancelled');
const averageTicket = completedOrders.length > 0 ? totalOrdersValue / completedOrders.length : 0;
document.getElementById('averageTicket').textContent = R$ ${averageTicket.toFixed(2)};
const paymentBreakdown = document.getElementById('paymentBreakdown');
paymentBreakdown.innerHTML = '';
for (const [method, value] of Object.entries(paymentMethods)) {
paymentBreakdown.innerHTML += <p>${translatePaymentMethod(method)}: R$ ${value.toFixed(2)}</p>;
}
saveDataToLocalStorage();
}
function updatePrepTimes(orders) {
const now = new Date();
orders.forEach(order => {
if (order.status === 'open' && !orderPrepTimes[order.id]) {
orderPrepTimes[order.id] = now.getTime();
} else if (order.status === 'onGoing' && orderPrepTimes[order.id]) {
const prepTime = (now.getTime() - orderPrepTimes[order.id]) / 60000; // em minutos
totalPrepTime += prepTime;
preparedOrders++;
delete orderPrepTimes[order.id];
}
const prepTimeElement = document.getElementById(prepTime-${order.id});
if (prepTimeElement) {
prepTimeElement.textContent = ${getPrepTimeForOrder(order.id)} min;
}
});
const avgPrepTime = preparedOrders > 0 ? totalPrepTime / preparedOrders : 0;
document.getElementById('avgPrepTime').textContent = ${avgPrepTime.toFixed(1)} min;
saveDataToLocalStorage();
}
function getPrepTimeForOrder(orderId) {
if (orderPrepTimes[orderId]) {
const now = new Date();
return ((now.getTime() - orderPrepTimes[orderId]) / 60000).toFixed(1);
}
return '0.0';
}
function updateCourierDeliveries(allOrders) {
const today = new Date();
today.setHours(0, 0, 0, 0);
courierDeliveries = {};
const ongoingDeliveries = {};
sameAddressOrders = {};
allOrders.forEach(order => {
if (order.courier && new Date(order.creationDate) >= today) {
const courierName = order.courier.courierName;
if (order.status === 'closed' || order.status === 'delivered') {
courierDeliveries[courierName] = (courierDeliveries[courierName] || 0) + 1;
} else if (['accepted', 'ready', 'onGoing', 'dispatched'].includes(order.status)) {
if (!ongoingDeliveries[courierName]) {
ongoingDeliveries[courierName] = [];
}
ongoingDeliveries[courierName].push(order);
// Check for same address deliveries
const address = ${order.deliveryPoint.street} ${order.deliveryPoint.houseNumber};
if (!sameAddressOrders[courierName]) {
sameAddressOrders[courierName] = {};
}
if (!sameAddressOrders[courierName][address]) {
sameAddressOrders[courierName][address] = [];
}
sameAddressOrders[courierName][address].push(order.id);
}
}
});
const courierDeliveriesElement = document.getElementById('courierDeliveries');
courierDeliveriesElement.innerHTML = '';
for (const [courierName, deliveries] of Object.entries(courierDeliveries)) {
const ongoingCount = ongoingDeliveries[courierName] ? ongoingDeliveries[courierName].length : 0;
let sameAddressInfo = '';
if (sameAddressOrders[courierName]) {
for (const [address, orders] of Object.entries(sameAddressOrders[courierName])) {
if (orders.length > 1) {
sameAddressInfo += <span class="same-address">${orders.length} mesma casa</span>, ;
}
}
sameAddressInfo = sameAddressInfo.slice(0, -2); // Remove last comma and space
}
courierDeliveriesElement.innerHTML +=     <div class="courier-deliveries">         <span class="courier-name">${courierName}</span>:          <strong>${deliveries}</strong> entrega${deliveries !== 1 ? 's' : ''} finalizadas         ${ongoingCount > 0 ?
| <strong>${ongoingCount}</strong> em andamento
${sameAddressInfo ? (${sameAddressInfo}) : ''}
<button class="view-button" onclick="showOngoingDeliveries('${courierName}')">Ver</button>
: ''}     </div>;
}
saveDataToLocalStorage();
}
function showOngoingDeliveries(courierName) {
const ongoingDeliveries = currentOrders.filter(order =>
order.courier &&
order.courier.courierName === courierName &&
['accepted', 'ready', 'onGoing', 'dispatched'].includes(order.status)
);
let content = <h3>Pedidos em andamento de <span class="courier-name">${courierName}</span></h3>;
if (ongoingDeliveries.length === 0) {
content += '<p>Nenhum pedido em andamento.</p>';
} else {
content += '<ul class="ongoing-orders-list">';
ongoingDeliveries.forEach(order => {
content +=             <li class="ongoing-order-item">                 <h4>Pedido #${order.id}</h4>                 <p>Cliente: ${order.customer.customerName}</p>                 <p>Endereço: ${order.deliveryPoint.address}</p>                 <p>Valor: R$ ${order.orderTotal.toFixed(2)}</p>                 <p>Status: ${getStatusDisplay(order.status)}</p>             </li>        ;
});
content += '</ul>';
}
const modal = document.getElementById('ongoingModal');
const modalContent = document.getElementById('ongoingContent');
modalContent.innerHTML = content;
modal.style.display = 'block';
}
function showReadyOrders() {
const readyOrders = currentOrders.filter(order => order.status === 'ready');
let content = <h3>Pedidos Prontos</h3>;
if (readyOrders.length === 0) {
content += '<p>Nenhum pedido pronto no momento.</p>';
} else {
content += '<ul class="ongoing-orders-list">';
readyOrders.forEach(order => {
content +=             <li class="ongoing-order-item">                 <h4>Pedido #${order.id}</h4>                 <p>Cliente: ${order.customer.customerName}</p>             </li>        ;
});
content += '</ul>';
}
const modal = document.getElementById('readyOrdersModal');
const modalContent = document.getElementById('readyOrdersContent');
modalContent.innerHTML = content;
modal.style.display = 'block';
}
function showPriorityOrders() {
const modal = document.getElementById('priorityOrdersModal');
const content = document.getElementById('priorityOrdersContent');
let ordersHtml = '<h3>Pedidos Prioritários</h3>';
if (priorityOrders.length === 0) {
ordersHtml += '<p>Nenhum pedido prioritário no momento.</p>';
} else {
ordersHtml += '<ul class="ongoing-orders-list">';
priorityOrders.forEach(order => {
ordersHtml +=             <li class="ongoing-order-item">                 <h4>Pedido #${order.id}</h4>                 <p>Cliente: ${order.customer.customerName}</p>                 <p>Endereço: ${order.deliveryPoint.address}</p>                 <p>Valor: R$ ${order.orderTotal ? order.orderTotal.toFixed(2) : 'N/A'}</p>             </li>        ;
});
ordersHtml += '</ul>';
}
content.innerHTML = ordersHtml;
modal.style.display = 'block';
}
function printPriorityOrders() {
const printWindow = window.open('', '', 'height=400,width=600');
let printContent = '<html><head><title>Pedidos Prioritários</title></head><body>';
printContent += '<h3>Pedidos Prioritários</h3>';
if (priorityOrders.length === 0) {
printContent += '<p>Nenhum pedido prioritário no momento.</p>';
} else {
priorityOrders.forEach(order => {
printContent += <p>Pedido #${order.id}</p>;
printContent += <p>Cliente: ${order.customer.customerName}</p>;
printContent += <p>Endereço: ${order.deliveryPoint.address}</p>;
printContent += <p>Valor: R$ ${order.orderTotal ? order.orderTotal.toFixed(2) : 'N/A'}</p>;
printContent += '<hr>';
});
}
printContent += '</body></html>';
printWindow.document.write(printContent);
printWindow.document.close();
printWindow.print();
}
function checkForCancelledOrders(orders) {
orders.forEach(order => {
if (order.status === 'cancelled' && lastOrderStatuses[order.id] !== 'cancelled') {
showCancellationPopup(order);
}
lastOrderStatuses[order.id] = order.status;
});
}
function showCancellationPopup(order) {
if (hiddenNotifications.cancellation) {
return;
}
const popup = document.getElementById('cancellationPopup');
const message = document.getElementById('cancellationMessage');
message.textContent = O pedido ${order.id} foi cancelado!${order.courier ?  Motoboy: ${order.courier.courierName} : ''};
popup.style.display = 'block';
}
function closeCancellationPopup() {
const popup = document.getElementById('cancellationPopup');
if (popup) {
popup.style.display = 'none';
}
}
function hideCancellationNotification() {
hiddenNotifications.cancellation = true;
closeCancellationPopup();
saveDataToLocalStorage();
}
function checkForSameAddressOrders(orders) {
const sameAddressMap = {};
const locationMap = {};
orders.forEach(order => {
if (order.status === 'closed' || order.status === 'cancelled') {
return;
}
const address = ${order.deliveryPoint.street} ${order.deliveryPoint.houseNumber};
const location = ${order.deliveryPoint.coordinates.lat},${order.deliveryPoint.coordinates.lng};
if (!sameAddressMap[address]) {
sameAddressMap[address] = [];
}
sameAddressMap[address].push(order);
if (!locationMap[location]) {
locationMap[location] = [];
}
locationMap[location].push(order);
});
let shouldShowNotification = false;
for (const [address, addressOrders] of Object.entries(sameAddressMap)) {
if (addressOrders.length > 1) {
shouldShowNotification = true;
break;
}
}
if (!shouldShowNotification) {
for (const [location, locationOrders] of Object.entries(locationMap)) {
if (locationOrders.length > 1) {
shouldShowNotification = true;
break;
}
}
}
if (shouldShowNotification && !hiddenNotifications.sameAddress) {
showSameAddressPopup(sameAddressMap, locationMap);
} else {
closeSameAddressPopup();
}
}
function showSameAddressPopup(sameAddressMap, locationMap) {
const now = new Date().getTime();
if (now - lastShownNotificationTime < 120000) { // 2 minutos
return;
}
const popup = document.getElementById('sameAddressPopup');
const message = document.getElementById('sameAddressMessage');
let content = '<strong>Pedidos para o mesmo endereço:</strong><br>';
for (const [address, orders] of Object.entries(sameAddressMap)) {
if (orders.length > 1) {
content += ${address}: Pedidos ${orders.map(order => order.id).join(', ')}<br>;
}
}
for (const [location, orders] of Object.entries(locationMap)) {
if (orders.length > 1) {
content += Localização ${location}: Pedidos ${orders.map(order => order.id).join(', ')}<br>;
}
}
message.innerHTML = content;
popup.style.display = 'block';
lastShownNotificationTime = now;
}
function closeSameAddressPopup() {
const popup = document.getElementById('sameAddressPopup');
if (popup) {
popup.style.display = 'none';
}
}
function hideSameAddressNotification() {
hiddenNotifications.sameAddress = true;
closeSameAddressPopup();
saveDataToLocalStorage();
}
function resetCounters() {
totalOrdersCount = 0;
totalOrdersValue = 0;
yesterdayOrdersValue = 0;
paymentMethods = {
money: 0,
card: 0,
online: 0
};
totalPrepTime = 0;
preparedOrders = 0;
orderPrepTimes = {};
courierDeliveries = {};
cancelledOrders = 0;
priorityOrders = [];
sameAddressOrders = {};
shownSameAddressNotifications.clear();
lastShownNotificationTime = 0;
hiddenNotifications = {
cancellation: false,
sameAddress: false
};
document.getElementById('avgPrepTime').textContent = '0.0 min';
document.getElementById('totalOrders').textContent = '0';
document.getElementById('ongoingOrders').textContent = '0';
document.getElementById('readyOrders').textContent = '0';
document.getElementById('cancelledOrders').textContent = '0';
document.getElementById('priorityOrders').textContent = '0';
document.getElementById('totalValue').textContent = 'R$ 0.00';
document.getElementById('yesterdayValue').textContent = 'R$ 0.00';
document.getElementById('averageTicket').textContent = 'R$ 0.00';
document.getElementById('paymentBreakdown').innerHTML = '';
document.getElementById('courierDeliveries').innerHTML = '';
saveDataToLocalStorage();
}
// Funções para o novo formulário de criação de pedidos
function toggleCreateOrderForm() {
const form = document.getElementById('createOrderForm');
const button = document.getElementById('toggleFormButton');
if (form.style.display === 'none') {
form.style.display = 'block';
button.textContent = 'Ocultar Formulário';
} else {
form.style.display = 'none';
button.textContent = 'Criar Novo Pedido';
}
}
async function submitOrder() {
const order = {
id: document.getElementById('orderId').value,
status: document.getElementById('status').value,
paymentMethod: document.querySelector('input[name="paymentMethod"]:checked').value,
orderTotal: Number(document.getElementById('orderTotal').value),
notes: document.getElementById('notes').value,
orderDetails: document.getElementById('orderDetails').value,
deliveryPoint: {
address: ${document.getElementById('street').value}, ${document.getElementById('streetNumber').value}, ${document.getElementById('neighborhood').value},
street: document.getElementById('street').value,
houseNumber: document.getElementById('streetNumber').value,
complement: document.getElementById('complement').value,
postalCode: document.getElementById('zipCode').value,
city: "Natal",
region: "RN",
country: "BR"
},
customer: {
customerPhone: document.getElementById('customerPhone').value,
customerName: document.getElementById('customerName').value
}
};
try {
const response = await fetch('https://us-central1-cabana-8d55e.cloudfunctions.net/foodyDeliveryApi/createOrder', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Authorization': authToken
},
body: JSON.stringify(order)
});
if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
}

const result = await response.json();
console.log('Pedido criado:', result);
alert('Pedido criado com sucesso!');
document.getElementById('createOrderForm').reset();
fetchOrders(); // Atualiza a lista de pedidos
} catch (error) {
console.error('Erro ao criar pedido:', error);
alert('Erro ao criar pedido: ' + error.message);
}
}
// Inicialização da aplicação
loadDataFromLocalStorage();
initMap();
fetchOrders();
setInterval(fetchOrders, 10000); // Atualiza a cada 10 segundos
// Configuração dos modais
const modals = document.querySelectorAll('.modal');
const closeSpans = document.querySelectorAll('.close');
closeSpans.forEach((span) => {
span.onclick = function() {
const modal = span.closest('.modal');
if (modal) {
modal.style.display = 'none';
}
}
});
window.onclick = function(event) {
modals.forEach(modal => {
if (event.target == modal) {
modal.style.display = 'none';
}
});
if (event.target == document.getElementById('cancellationPopup')) {
closeCancellationPopup();
}
if (event.target == document.getElementById('sameAddressPopup')) {
closeSameAddressPopup();
}
}
</script>
</body>
</html>
